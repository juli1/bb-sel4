diff --git a/include/plat/am335x/plat/machine/devices.h b/include/plat/am335x/plat/machine/devices.h
index 8c9704e..273ce85 100644
--- a/include/plat/am335x/plat/machine/devices.h
+++ b/include/plat/am335x/plat/machine/devices.h
@@ -17,11 +17,15 @@
 #define DMTIMER0_PPTR  0xfff03000
 #define WDT1_PPTR 0xfff04000
 #define CMPER_PPTR 0xfff05000
+#define CONTROL_PPTR 0xfff05000
 
 
 /* Other devices on the SoC. */
 #define INTC_PADDR      0x48200000
 #define UART0_PADDR     0x44E09000
+#define UART1_PADDR     0x48022000
+#define CONTROL_PADDR   0x44E10000
+#define PRCM_PADDR      0x44E00000
 #define DMTIMER0_PADDR  0x44E05000
 #define DMTIMER2_PADDR  0x48040000
 #define DMTIMER3_PADDR  0x48042000
@@ -32,5 +36,18 @@
 #define WDT1_PADDR      0x44e35000
 #define CMPER_PADDR     0x44e00000
 
+#define SS_REGS                     0x4A100000
+#define MDIO_REGS                   0x4A101000
+#define WR_REGS                     0x4A101200
+#define CPDMA_REGS                  0x4A100800
+#define ALE_REGS                    0x4A100D00
+#define STAT_REGS                   0x4A100900
+#define PORT_0_REGS                 0x4A100100
+#define PORT_1_REGS                 0x4A100200
+#define SLIVER_1_REGS               0x4A100D80
+#define PORT_2_REGS                 0x4A100300
+#define SLIVER_2_REGS               0x4A100DC0
+#define CPPI_RAM_REGS               0x4A102000
+
 
 #endif
diff --git a/include/plat/omap3/plat/machine/devices.h b/include/plat/omap3/plat/machine/devices.h
index a344384..7000da9 100644
--- a/include/plat/omap3/plat/machine/devices.h
+++ b/include/plat/omap3/plat/machine/devices.h
@@ -138,4 +138,19 @@
 #define L3_SDRC_CONFIG                 0x68D00000 /* 16MB */
 #define L3_GPMC_CONFIG                 0x68E00000 /* 16MB */
 
+
+#define SS_REGS                     (0x4A100000)
+#define MDIO_REGS                   (0x4A101000)
+#define WR_REGS                     (0x4A101200)
+#define CPDMA_REGS                  (0x4A100800)
+#define ALE_REGS                    (0x4A100D00)
+#define STAT_REGS                   (0x4A100900)
+#define PORT_0_REGS                 (0x4A100100)
+#define PORT_1_REGS                 (0x4A100200)
+#define SLIVER_1_REGS               (0x4A100D80)
+#define PORT_2_REGS                 (0x4A100300)
+#define SLIVER_2_REGS               (0x4A100DC0)
+#define CPPI_RAM_REGS               (0x4A102000)
+
+
 #endif
diff --git a/src/plat/am335x/machine/hardware.c b/src/plat/am335x/machine/hardware.c
index aa711f9..faded23 100644
--- a/src/plat/am335x/machine/hardware.c
+++ b/src/plat/am335x/machine/hardware.c
@@ -19,6 +19,8 @@
 #include <plat/machine/devices.h>
 #include <plat/machine/hardware.h>
 
+static void configureUartClocks(void);
+
 /* pointer to end of kernel image */
 /* need a fake array to get the pointer from the linker script */
 extern char ki_end[1];
@@ -44,6 +46,14 @@ BOOT_CODE p_region_t get_avail_p_reg(word_t i)
 const p_region_t BOOT_RODATA dev_p_regs[] = {
     /* SoC devices: */
     { /* .start = */ UART0_PADDR,    /* .end = */ UART0_PADDR + (1 << PAGE_BITS) },
+    { /* .start = */ UART1_PADDR,    /* .end = */ UART1_PADDR + (1 << PAGE_BITS) },
+
+    { /* .start = */ SS_REGS,    /* .end = */ SS_REGS + (1 << PAGE_BITS) },
+    { /* .start = */ MDIO_REGS,    /* .end = */ MDIO_REGS + (1 << PAGE_BITS) },
+    { /* .start = */ CPPI_RAM_REGS,    /* .end = */ CPPI_RAM_REGS + (2 << PAGE_BITS) },
+
+    { /* .start = */ PRCM_PADDR,    /* .end = */ PRCM_PADDR + (1 << PAGE_BITS) },
+    { /* .start = */ CONTROL_PADDR,    /* .end = */ CONTROL_PADDR + (1 << PAGE_BITS) },
     { /* .start = */ DMTIMER2_PADDR, /* .end = */ DMTIMER2_PADDR + (1 << PAGE_BITS) },
     { /* .start = */ DMTIMER3_PADDR, /* .end = */ DMTIMER3_PADDR + (1 << PAGE_BITS) },
     { /* .start = */ DMTIMER4_PADDR, /* .end = */ DMTIMER4_PADDR + (1 << PAGE_BITS) },
@@ -135,6 +145,7 @@ map_kernel_devices(void)
 
 #define CMPER_REG(base, off) ((volatile uint32_t *)((base) + (off)))
 #define CMPER_TIMER3_CLKCTRL    0x84
+#define CMPER_L4LS_CLKCTRL   (0x60)
 #define CMPER_CLKCTRL_DISABLE   0
 #define CMPER_CLKCTRL_ENABLE    2
 #define CMPER_CLKSEL_TIMER3     0x50c
@@ -227,6 +238,7 @@ void handleReservedIRQ(irq_t irq)
 void
 ackInterrupt(irq_t irq)
 {
+
     /*
      * am335x ref man, sec 6.2.2 only requires a DSB after NEWIRQAGR.
      * I found that without dsb() or more code before, I get interrupts
@@ -308,6 +320,26 @@ disableWatchdog(void)
     }
 }
 
+#define CMPER_UART1_CLKCTRL   (0x6c)
+
+
+#define CMPER_UART1_CLKCTRL_IDLEST   (0x00030000u)
+#define CMPER_UART1_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
+#define CMPER_UART1_CLKCTRL_IDLEST_DISABLE   (0x3u)
+#define CMPER_UART1_CLKCTRL_IDLEST_FUNC   (0x0u)
+#define CMPER_UART1_CLKCTRL_IDLEST_IDLE   (0x2u)
+#define CMPER_UART1_CLKCTRL_IDLEST_TRANS   (0x1u)
+
+#define CMPER_UART1_CLKCTRL_MODULEMODE   (0x00000003u)
+#define CMPER_UART1_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
+#define CMPER_UART1_CLKCTRL_MODULEMODE_DISABLED   (0x0u)
+#define CMPER_UART1_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
+#define CMPER_UART1_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
+#define CMPER_UART1_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)
+
+#define CMPER_L4LS_CLKSTCTRL   (0x0)
+#define CMPER_L4LS_CLKSTCTRL_CLKACTIVITY_LCDC_GCLK   (0x00020000u)
+
 /*
  * Enable DMTIMER clocks, otherwise their registers wont be accessible.
  * This could be moved out of kernel.
@@ -329,6 +361,8 @@ enableTimers(void)
     while ((*CMPER_REG(cmper, CMPER_TIMER3_CLKCTRL) & 3) != CMPER_CLKCTRL_ENABLE) {
         continue;
     }
+
+    configureUartClocks();
 }
 
 /* Configure dmtimer0 as kernel preemption timer */
@@ -390,3 +424,306 @@ void plat_invalidateL2Range(paddr_t start, paddr_t end) {}
 void plat_cleanInvalidateL2Range(paddr_t start, paddr_t end) {}
 
 
+#define SOC_PRCM_REGS CMPER_PPTR
+#define SOC_CM_PER_REGS (SOC_PRCM_REGS + 0)
+#define SOC_CM_WKUP_REGS (SOC_PRCM_REGS + 0x400)
+#define HWREG(x) (*((volatile unsigned int *)(x)))
+#define TRUE 1
+#define FALSE 0
+
+
+/**
+Add for ethernet/timer7
+*/
+
+#define SOC_CM_DPLL_REGS                     (SOC_PRCM_REGS + 0x500)
+#define CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL   (0x00000003u)
+#define CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_SHIFT   (0x00000000u)
+#define CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_SEL1   (0x0u)
+#define CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_CLK_M_OSC   (0x1u)
+#define CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_SEL3   (0x2u)
+#define CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_SEL4   (0x3u)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK   (0x00000100u)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK_SHIFT   (0x00000008u)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK_ACT   (0x1u)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK_INACT   (0x0u)
+#define CM_PER_TIMER7_CLKCTRL   (0x7c)
+#define CM_PER_TIMER2_CLKCTRL   (0x80)
+#define CM_PER_TIMER3_CLKCTRL   (0x84)
+#define CM_PER_TIMER4_CLKCTRL   (0x88)
+
+
+#define CM_PER_TIMER7_CLKCTRL_IDLEST   (0x00030000u)
+#define CM_PER_TIMER7_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
+#define CM_PER_TIMER7_CLKCTRL_IDLEST_DISABLED   (0x3u)
+#define CM_PER_TIMER7_CLKCTRL_IDLEST_FUNC   (0x0u)
+#define CM_PER_TIMER7_CLKCTRL_IDLEST_IDLE   (0x2u)
+#define CM_PER_TIMER7_CLKCTRL_IDLEST_TRANS   (0x1u)
+
+#define CM_PER_TIMER7_CLKCTRL_MODULEMODE   (0x00000003u)
+#define CM_PER_TIMER7_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
+#define CM_PER_TIMER7_CLKCTRL_MODULEMODE_DISABLE   (0x0u)
+#define CM_PER_TIMER7_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
+#define CM_PER_TIMER7_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
+#define CM_PER_TIMER7_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)
+
+#define CM_PER_L4LS_CLKSTCTRL   (0x0)
+
+
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK   (0x00002000u)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK_SHIFT   (0x0000000Du)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK_ACT   (0x1u)
+#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK_INACT   (0x0u)
+
+#define CM_DPLL_CLKSEL_TIMER7_CLK   (0x4)
+
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK   (0x00000020u)
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK_SHIFT   (0x00000005u)
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK_ACT   (0x1u)
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK_INACT   (0x0u)
+
+
+
+/**
+end of add for ethernet/timer7
+*/
+
+// from uart.c
+//#include "hw_cm_wkup.h"
+#define CM_WKUP_CLKSTCTRL (0x0)
+#define CM_WKUP_CONTROL_CLKCTRL (0x4)
+#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE (0x00000003u)
+#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE (0x2u)
+#define CM_WKUP_CLKSTCTRL_CLKTRCTRL (0x00000003u)
+#define CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_WKUP (0x2u)
+#define CM_WKUP_CM_L3_AON_CLKSTCTRL (0x18)
+#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL (0x00000003u)
+#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP (0x2u)
+#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK (0x00000008u)
+#define CM_WKUP_UART0_CLKCTRL (0xb4)
+#define CM_WKUP_UART0_CLKCTRL_MODULEMODE (0x00000003u)
+#define CM_WKUP_UART0_CLKCTRL_MODULEMODE_ENABLE (0x2u)
+#define CM_WKUP_CONTROL_CLKCTRL_IDLEST (0x00030000u)
+#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_SHIFT (0x00000010u)
+#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_FUNC (0x0u)
+#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST (0x00030000u)
+#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_SHIFT (0x00000010u)
+#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_FUNC (0x0u)
+#define CM_WKUP_L4WKUP_CLKCTRL (0xc)
+#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK (0x00000004u)
+#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK (0x00000004u)
+#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL (0xcc)
+#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK (0x00001000u)
+#define CM_WKUP_UART0_CLKCTRL_IDLEST (0x00030000u)
+#define CM_WKUP_UART0_CLKCTRL_IDLEST_SHIFT (0x00000010u)
+#define CM_WKUP_UART0_CLKCTRL_IDLEST_FUNC (0x0u)
+//#include "hw_cm_per.h"
+#define CM_PER_L3S_CLKSTCTRL (0x4)
+#define CM_PER_L3_CLKCTRL (0xe0)
+#define CM_PER_L3_CLKSTCTRL (0xc)
+#define CM_PER_L3_CLKCTRL_MODULEMODE (0x00000003u)
+#define CM_PER_L3_CLKCTRL_MODULEMODE_ENABLE (0x2u)
+#define CM_PER_L3_INSTR_CLKCTRL (0xdc)
+#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE (0x00000003u)
+#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_ENABLE (0x2u)
+#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL (0x00000003u)
+#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP (0x2u)
+#define CM_PER_OCPWP_L3_CLKSTCTRL (0x12c)
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL (0x00000003u)
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP (0x2u)
+#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL (0x00000003u)
+#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_WKUP (0x2u)
+#define CM_PER_L3_CLKCTRL_IDLEST (0x00030000u)
+#define CM_PER_L3_CLKCTRL_IDLEST_SHIFT (0x00000010u)
+#define CM_PER_L3_CLKCTRL_IDLEST_FUNC (0x0u)
+#define CM_PER_L3_INSTR_CLKCTRL_IDLEST (0x00030000u)
+#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_SHIFT (0x00000010u)
+#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_FUNC (0x0u)
+#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK (0x00000010u)
+#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK (0x00000010u)
+#define CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK (0x00000008u)
+#define REG(x)(*((volatile uint32_t *)(x)))
+
+static void configureUartClocks() {
+	// Configuring L3 Interface Clocks
+	// Writing to MODULEMODE field of CM_PER_L3_CLKCTRL register
+	HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKCTRL) |= CM_PER_L3_CLKCTRL_MODULEMODE_ENABLE;
+	// Waiting for MODULEMODE field to reflect the written value
+	while(CM_PER_L3_CLKCTRL_MODULEMODE_ENABLE != (HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKCTRL) &
+				CM_PER_L3_CLKCTRL_MODULEMODE));
+	// Writing to MODULEMODE field of CM_PER_L3_INSTR_CLKCTRL register
+	HWREG(SOC_CM_PER_REGS + CM_PER_L3_INSTR_CLKCTRL) |= CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_ENABLE;
+	// Waiting for MODULEMODE field to reflect the written value
+	while(CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_ENABLE != (HWREG(SOC_CM_PER_REGS + CM_PER_L3_INSTR_CLKCTRL) &
+				CM_PER_L3_INSTR_CLKCTRL_MODULEMODE));
+	// Writing to CLKTRCTRL field of CM_PER_L3_CLKSTCTRL register
+	HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKSTCTRL) |= CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP;
+	// Waiting for CLKTRCTRL field to reflect the written value
+	while(CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKSTCTRL) &
+				CM_PER_L3_CLKSTCTRL_CLKTRCTRL));
+	// Writing to CLKTRCTRL field of CM_PER_OCPWP_L3_CLKSTCTRL register
+	HWREG(SOC_CM_PER_REGS + CM_PER_OCPWP_L3_CLKSTCTRL) |= CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP;
+	//Waiting for CLKTRCTRL field to reflect the written value
+	while(CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (HWREG(SOC_CM_PER_REGS + CM_PER_OCPWP_L3_CLKSTCTRL) &
+				CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL));
+	// Writing to CLKTRCTRL field of CM_PER_L3S_CLKSTCTRL register
+	HWREG(SOC_CM_PER_REGS + CM_PER_L3S_CLKSTCTRL) |= CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_WKUP;
+	//Waiting for CLKTRCTRL field to reflect the written value
+	while(CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (HWREG(SOC_CM_PER_REGS + CM_PER_L3S_CLKSTCTRL) &
+				CM_PER_L3S_CLKSTCTRL_CLKTRCTRL));
+	// Checking fields for necessary values
+	// Waiting for IDLEST field in CM_PER_L3_CLKCTRL register to be set to 0x0
+	while((CM_PER_L3_CLKCTRL_IDLEST_FUNC << CM_PER_L3_CLKCTRL_IDLEST_SHIFT)!=
+			(HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKCTRL) & CM_PER_L3_CLKCTRL_IDLEST));
+	// Waiting for IDLEST field in CM_PER_L3_INSTR_CLKCTRL register to attain the desired value.
+	while((CM_PER_L3_INSTR_CLKCTRL_IDLEST_FUNC << CM_PER_L3_INSTR_CLKCTRL_IDLEST_SHIFT)!=
+			(HWREG(SOC_CM_PER_REGS + CM_PER_L3_INSTR_CLKCTRL) & CM_PER_L3_INSTR_CLKCTRL_IDLEST));
+	// Waiting for CLKACTIVITY_L3_GCLK field in CM_PER_L3_CLKSTCTRL register to attain the desired value.
+	while(CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK != (HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKSTCTRL) &
+				CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK));
+	// Waiting for CLKACTIVITY_OCPWP_L3_GCLK field in CM_PER_OCPWP_L3_CLKSTCTRL register to attain the desired value.
+	while(CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK != (HWREG(SOC_CM_PER_REGS + CM_PER_OCPWP_L3_CLKSTCTRL) &
+				CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK));
+	// Waiting for CLKACTIVITY_L3S_GCLK field in CM_PER_L3S_CLKSTCTRL register to attain the desired value.
+	while(CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK != (HWREG(SOC_CM_PER_REGS + CM_PER_L3S_CLKSTCTRL) &
+				CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK));
+	// Configuring registers related to Wake-Up region
+	// Writing to MODULEMODE field of CM_WKUP_CONTROL_CLKCTRL register
+	HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CONTROL_CLKCTRL) |= CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE;
+	// Waiting for MODULEMODE field to reflect the written value
+	while(CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE != (HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CONTROL_CLKCTRL) &
+				CM_WKUP_CONTROL_CLKCTRL_MODULEMODE));
+	// Writing to CLKTRCTRL field of CM_PER_L3S_CLKSTCTRL register
+	HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CLKSTCTRL) |= CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_WKUP;
+	//Waiting for CLKTRCTRL field to reflect the written value
+	while(CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CLKSTCTRL) &
+				CM_WKUP_CLKSTCTRL_CLKTRCTRL));
+	// Writing to CLKTRCTRL field of CM_L3_AON_CLKSTCTRL register
+	HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CM_L3_AON_CLKSTCTRL) |= CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP;
+	//Waiting for CLKTRCTRL field to reflect the written value
+	while(CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CM_L3_AON_CLKSTCTRL) &
+				CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL));
+	// Writing to MODULEMODE field of CM_WKUP_UART0_CLKCTRL register
+	HWREG(SOC_CM_WKUP_REGS + CM_WKUP_UART0_CLKCTRL) |= CM_WKUP_UART0_CLKCTRL_MODULEMODE_ENABLE;
+	// Waiting for MODULEMODE field to reflect the written value
+	while(CM_WKUP_UART0_CLKCTRL_MODULEMODE_ENABLE != (HWREG(SOC_CM_WKUP_REGS + CM_WKUP_UART0_CLKCTRL) &
+				CM_WKUP_UART0_CLKCTRL_MODULEMODE));
+	// Verifying if the other bits are set to required settings
+	//
+	// Waiting for IDLEST field in CM_WKUP_CONTROL_CLKCTRL register to attain desired value.
+	while((CM_WKUP_CONTROL_CLKCTRL_IDLEST_FUNC << CM_WKUP_CONTROL_CLKCTRL_IDLEST_SHIFT) !=
+			(HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CONTROL_CLKCTRL) & CM_WKUP_CONTROL_CLKCTRL_IDLEST));
+	// Waiting for CLKACTIVITY_L3_AON_GCLK field in CM_L3_AON_CLKSTCTRL register to attain desired value.
+	while(CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK !=
+			(HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CM_L3_AON_CLKSTCTRL) &
+			 CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK));
+	// Waiting for IDLEST field in CM_WKUP_L4WKUP_CLKCTRL register to attain desired value.
+	while((CM_WKUP_L4WKUP_CLKCTRL_IDLEST_FUNC << CM_WKUP_L4WKUP_CLKCTRL_IDLEST_SHIFT) !=
+			(HWREG(SOC_CM_WKUP_REGS + CM_WKUP_L4WKUP_CLKCTRL) & CM_WKUP_L4WKUP_CLKCTRL_IDLEST));
+	// Waiting for CLKACTIVITY_L4_WKUP_GCLK field in CM_WKUP_CLKSTCTRL register to attain desired value.
+	while(CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK != (HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CLKSTCTRL) &
+				CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK));
+	// Waiting for CLKACTIVITY_L4_WKUP_AON_GCLK field in CM_L4_WKUP_AON_CLKSTCTRL register to attain desired value.
+	while(CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK !=
+			(HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL) &
+			 CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK));
+	// Waiting for CLKACTIVITY_UART0_GFCLK field in CM_WKUP_CLKSTCTRL register to attain desired value.
+	while(CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK != (HWREG(SOC_CM_WKUP_REGS + CM_WKUP_CLKSTCTRL) &
+				CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK));
+	// Waiting for IDLEST field in CM_WKUP_UART0_CLKCTRL register to attain desired value.
+	while((CM_WKUP_UART0_CLKCTRL_IDLEST_FUNC << CM_WKUP_UART0_CLKCTRL_IDLEST_SHIFT) !=
+			(HWREG(SOC_CM_WKUP_REGS + CM_WKUP_UART0_CLKCTRL) & CM_WKUP_UART0_CLKCTRL_IDLEST));
+
+
+
+	/**
+change for timer7
+*/
+    /* Select the clock source for the Timer7 instance. */
+    HWREG(SOC_CM_DPLL_REGS + CM_DPLL_CLKSEL_TIMER7_CLK) &=
+          ~(CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL);
+
+    HWREG(SOC_CM_DPLL_REGS + CM_DPLL_CLKSEL_TIMER7_CLK) |=
+          CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_CLK_M_OSC;
+
+    while((HWREG(SOC_CM_DPLL_REGS + CM_DPLL_CLKSEL_TIMER7_CLK) &
+           CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL) !=
+           CM_DPLL_CLKSEL_TIMER7_CLK_CLKSEL_CLK_M_OSC);
+
+    HWREG(SOC_CM_PER_REGS + CM_PER_TIMER7_CLKCTRL) |=
+                             CM_PER_TIMER7_CLKCTRL_MODULEMODE_ENABLE;
+    while((HWREG(SOC_CM_PER_REGS + CM_PER_TIMER7_CLKCTRL) &
+     CM_PER_TIMER7_CLKCTRL_MODULEMODE) != CM_PER_TIMER7_CLKCTRL_MODULEMODE_ENABLE);
+
+    while((HWREG(SOC_CM_PER_REGS + CM_PER_TIMER7_CLKCTRL) &
+     CM_PER_TIMER7_CLKCTRL_IDLEST) != CM_PER_TIMER7_CLKCTRL_IDLEST_FUNC);
+
+    while(!(HWREG(SOC_CM_PER_REGS + CM_PER_L3S_CLKSTCTRL) &
+            CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK));
+
+    while(!(HWREG(SOC_CM_PER_REGS + CM_PER_L3_CLKSTCTRL) &
+            CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK));
+
+    while(!(HWREG(SOC_CM_PER_REGS + CM_PER_OCPWP_L3_CLKSTCTRL) &
+           (CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK |
+            CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK)));
+
+    while(!(HWREG(SOC_CM_PER_REGS + CM_PER_L4LS_CLKSTCTRL) &
+           (CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK |
+            CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK)));
+
+
+	/**
+ETH block
+*/
+
+#define CM_PER_CPGMAC0_CLKCTRL   (0x14)
+#define CM_PER_CPGMAC0_CLKCTRL_IDLEST   (0x00030000u)
+#define CM_PER_CPGMAC0_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
+#define CM_PER_CPGMAC0_CLKCTRL_IDLEST_DISABLED   (0x3u)
+#define CM_PER_CPGMAC0_CLKCTRL_IDLEST_FUNC   (0x0u)
+#define CM_PER_CPGMAC0_CLKCTRL_IDLEST_IDLE   (0x2u)
+#define CM_PER_CPGMAC0_CLKCTRL_IDLEST_TRANS   (0x1u)
+
+#define CM_PER_CPGMAC0_CLKCTRL_MODULEMODE   (0x00000003u)
+#define CM_PER_CPGMAC0_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
+#define CM_PER_CPGMAC0_CLKCTRL_MODULEMODE_DISABLE   (0x0u)
+#define CM_PER_CPGMAC0_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
+#define CM_PER_CPGMAC0_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
+#define CM_PER_CPGMAC0_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)
+
+#define CM_PER_CPGMAC0_CLKCTRL_STBYST   (0x00040000u)
+#define CM_PER_CPGMAC0_CLKCTRL_STBYST_SHIFT   (0x00000012u)
+#define CM_PER_CPGMAC0_CLKCTRL_STBYST_FUNC   (0x0u)
+#define CM_PER_CPGMAC0_CLKCTRL_STBYST_STANDBY   (0x1u)
+
+#define CM_PER_CPSW_CLKSTCTRL_CLKACTIVITY_CPSW_125MHZ_GCLK   (0x00000010u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKACTIVITY_CPSW_125MHZ_GCLK_SHIFT   (0x00000004u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKACTIVITY_CPSW_125MHZ_GCLK_ACT   (0x1u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKACTIVITY_CPSW_125MHZ_GCLK_INACT   (0x0u)
+
+#define CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
+#define CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)
+
+#define CM_PER_CPSW_CLKSTCTRL   (0x144)
+
+
+
+    HWREG(SOC_PRCM_REGS + CM_PER_CPGMAC0_CLKCTRL) =
+                      CM_PER_CPGMAC0_CLKCTRL_MODULEMODE_ENABLE;
+
+    while(0 != (HWREG(SOC_PRCM_REGS + CM_PER_CPGMAC0_CLKCTRL)
+                & CM_PER_CPGMAC0_CLKCTRL_IDLEST));
+
+    HWREG(SOC_PRCM_REGS + CM_PER_CPSW_CLKSTCTRL) =
+                      CM_PER_CPSW_CLKSTCTRL_CLKTRCTRL_SW_WKUP;
+
+    while(0 == (HWREG(SOC_PRCM_REGS + CM_PER_CPSW_CLKSTCTRL)
+                & CM_PER_CPSW_CLKSTCTRL_CLKACTIVITY_CPSW_125MHZ_GCLK));
+
+}
+
